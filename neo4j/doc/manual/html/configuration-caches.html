<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>21.4. Caches in Neo4j</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The Neo4j Manual v1.9.M04" /><link rel="up" href="embedded-configuration.html" title="Chapter 21. Configuration &amp; Performance" /><link rel="prev" href="kernel-configuration.html" title="21.3. Kernel configuration" /><link rel="next" href="configuration-logical-logs.html" title="21.5. Logical logs" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 4. Using Neo4j embedded in Java applications" /><link rel="chapter" href="tutorials-rest.html" title="Chapter 5. Neo4j Remote Client Libraries" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 6. The Traversal Framework" /><link rel="chapter" href="data-modeling-examples.html" title="Chapter 7. Data Modeling Examples" /><link rel="chapter" href="languages.html" title="Chapter 8. Languages" /><link rel="chapter" href="tutorials-python-embedded.html" title="Chapter 9. Using Neo4j embedded in Python applications" /><link rel="chapter" href="server-extending.html" title="Chapter 10. Extending the Neo4j Server" /><link rel="part" href="reference-documentation.html" title="Part III. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 11. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 12. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 13. Data Import" /><link rel="chapter" href="indexing.html" title="Chapter 14. Indexing" /><link rel="chapter" href="cypher-query-lang.html" title="Chapter 15. Cypher Query Language" /><link rel="chapter" href="graph-algo.html" title="Chapter 16. Graph Algorithms" /><link rel="chapter" href="server.html" title="Chapter 17. Neo4j Server" /><link rel="chapter" href="rest-api.html" title="Chapter 18. REST API" /><link rel="chapter" href="python-embedded.html" title="Chapter 19. Python embedded bindings" /><link rel="part" href="operations.html" title="Part IV. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 20. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 21. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 22. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 23. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 24. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 25. Monitoring" /><link rel="part" href="tools.html" title="Part V. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 26. Web Administration" /><link rel="chapter" href="shell.html" title="Chapter 27. Neo4j Shell" /><link rel="part" href="community.html" title="Part VI. Community" /><link rel="chapter" href="community-support.html" title="Chapter 28. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 29. Contributing to Neo4j" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-shell" /><link rel="refentry" href="re03.html" title="neo4j-backup" /><link rel="appendix" href="questions.html" title="Appendix B. Questions &amp; Answers" /><link rel="subsection" href="configuration-caches.html#_file_buffer_cache" title="21.4.1. File buffer cache" /><link rel="subsection" href="configuration-caches.html#_object_cache" title="21.4.2. Object cache" /><link rel="copyright" href="ln-idp3423008.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>
<script type="text/javascript" src="js/shBrushProperties.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="operations.html">Operations</a></span> &gt; <span class="breadcrumb-link"><a href="embedded-configuration.html">Configuration &amp; Performance</a></span> &gt; <span class="breadcrumb-node">Caches in Neo4j</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="kernel-configuration.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="configuration-logical-logs.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="configuration-caches"></a>21.4. Caches in Neo4j</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="configuration-caches.html#_file_buffer_cache">21.4.1. File buffer cache</a></span></dt><dt><span class="section"><a href="configuration-caches.html#_object_cache">21.4.2. Object cache</a></span></dt></dl></div><p>For how to provide custom configuration to Neo4j, see <a class="xref" href="configuration-introduction.html" title="21.1. Introduction">Section 21.1, “Introduction”</a>.</p><p>Neo4j utilizes two different types of caches:
A file buffer cache and an object cache.
The file buffer cache caches the storage file data in the same format as it is stored on the durable storage media.
The object cache caches the nodes, relationships and properties in a format that is optimized for high traversal speeds and transactional writes.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_file_buffer_cache"></a>21.4.1. File buffer cache</h3></div></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Quick info</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The file buffer cache is sometimes called <span class="emphasis"><em>low level cache</em></span> or <span class="emphasis"><em>file system cache</em></span>.
</li><li class="listitem">
It caches the Neo4j data as stored on the durable media.
</li><li class="listitem">
It uses the operating system memory mapping features when possible.
</li><li class="listitem">
Neo4j will configure the cache automatically as long as the heap size of the JVM is configured properly.
</li></ul></div></div><p>The file buffer cache caches the Neo4j data in the same format as it is represented on the durable storage media.
The purpose of this cache layer is to improve both read and write performance.
The file buffer cache improves write performance by writing to the cache and deferring durable write until the logical log is rotated.
This behavior is safe since all transactions are always durably written to the logical log, which can be used to recover the store files in the event of a crash.</p><p>Since the operation of the cache is tightly related to the data it stores, a short description of the Neo4j durable representation format is necessary background.
Neo4j stores data in multiple files and relies on the underlying file system to handle this efficiently.
Each Neo4j storage file contains uniform fixed size records of a particular type:</p><div class="informaltable"><table cellspacing="0" cellpadding="0" border="0" width="50%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th align="left" valign="top"> Store file         </th><th align="right" valign="top"> Record size </th><th align="left" valign="top"> Contents</th></tr></thead><tbody><tr><td align="left" valign="top"><p>nodestore</p></td><td align="right" valign="top"><p><code class="literal">9 B</code></p></td><td align="left" valign="top"><p>Nodes</p></td></tr><tr><td align="left" valign="top"><p>relstore</p></td><td align="right" valign="top"><p><code class="literal">33 B</code></p></td><td align="left" valign="top"><p>Relationships</p></td></tr><tr><td align="left" valign="top"><p>propstore</p></td><td align="right" valign="top"><p><code class="literal">41 B</code></p></td><td align="left" valign="top"><p>Properties for nodes and relationships</p></td></tr><tr><td align="left" valign="top"><p>stringstore</p></td><td align="right" valign="top"><p><code class="literal">128 B</code></p></td><td align="left" valign="top"><p>Values of string properties</p></td></tr><tr><td align="left" valign="top"><p>arraystore</p></td><td align="right" valign="top"><p><code class="literal">128 B</code></p></td><td align="left" valign="top"><p>Values of array properties</p></td></tr></tbody></table></div><p>For strings and arrays, where data can be of variable length, data is stored in one or more 120B chunks, with 8B record overhead.
The sizes of these blocks can actually be configured when the store is created using the <code class="literal">string_block_size</code> and <code class="literal">array_block_size</code> parameters.
The size of each record type can also be used to calculate the storage requirements of a Neo4j graph or the appropriate cache size for each file buffer cache.
Note that some strings and arrays can be stored without using the string store or the array store respectively, see <a class="xref" href="short-strings.html" title="21.7. Compressed storage of short strings">Section 21.7, “Compressed storage of short strings”</a> and <a class="xref" href="short-arrays.html" title="21.8. Compressed storage of short arrays">Section 21.8, “Compressed storage of short arrays”</a>.</p><p>Neo4j uses multiple file buffer caches, one for each different storage file.
Each file buffer cache divides its storage file into a number of equally sized windows.
Each cache window contains an even number of storage records.
The cache holds the most active cache windows in memory and tracks hit vs. miss ratio for the windows.
When the hit ratio of an uncached window gets higher than the miss ratio of a cached window, the cached window gets evicted and the previously uncached window is cached instead.</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/admon/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>Note that the block sizes can only be configured at store creation time.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_configuration"></a>Configuration</h4></div></div></div><div class="informaltable"><table cellspacing="0" cellpadding="0" border="0"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th align="left" valign="top"> Parameter                 </th><th align="left" valign="top"> Possible values   </th><th align="left" valign="top"> Effect</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">use_memory_mapped_buffers</code></p></td><td align="left" valign="top"><p><code class="literal">true</code> or <code class="literal">false</code></p></td><td align="left" valign="top"><p>If set to <code class="literal">true</code> Neo4j will use the operating systems memory mapping functionality for the file buffer cache windows.
  If set to <code class="literal">false</code> Neo4j will use its own buffer implementation.
  In this case the buffers will reside in the JVM heap which needs to be increased accordingly.
  The default value for this parameter is <code class="literal">true</code>, except on Windows.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">neostore.nodestore.db.mapped_memory</code></p></td><td rowspan="7" align="center" valign="middle"><p>The maximum amount of memory to use for memory mapped buffers for this file buffer cache.
  The default unit is <code class="literal">MiB</code>, for other units use any of the following suffixes: <code class="literal">B</code>, <code class="literal">k</code>, <code class="literal">M</code> or <code class="literal">G</code>.</p></td><td align="left" valign="top"><p>The maximum amount of memory to use for the file buffer cache of the node storage file.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">neostore.relationshipstore.db.mapped_memory</code></p></td><td align="left" valign="top"><p>The maximum amount of memory to use for the file buffer cache of the relationship store file.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">neostore.propertystore.db.index.keys.mapped_memory</code></p></td><td align="left" valign="top"><p>The maximum amount of memory to use for the file buffer cache of the something-something file.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">neostore.propertystore.db.index.mapped_memory</code></p></td><td align="left" valign="top"><p>The maximum amount of memory to use for the file buffer cache of the something-something file.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">neostore.propertystore.db.mapped_memory</code></p></td><td align="left" valign="top"><p>The maximum amount of memory to use for the file buffer cache of the property storage file.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">neostore.propertystore.db.strings.mapped_memory</code></p></td><td align="left" valign="top"><p>The maximum amount of memory to use for the file buffer cache of the string property storage file.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">neostore.propertystore.db.arrays.mapped_memory</code></p></td><td align="left" valign="top"><p>The maximum amount of memory to use for the file buffer cache of the array property storage file.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">string_block_size</code></p></td><td rowspan="2" align="center" valign="middle"><p>The number of bytes per block.</p></td><td align="left" valign="top"><p>Specifies the block size for storing strings.
  This parameter is only honored when the store is created, otherwise it is ignored.
  Note that each character in a string occupies two bytes, meaning that a block size of 120 (the default size) will hold a 60 character long string before overflowing into a second block.
  Also note that each block carries an overhead of 8 bytes.
  This means that if the block size is 120, the size of the stored records will be 128 bytes.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">array_block_size</code></p></td><td align="left" valign="top"><p>Specifies the block size for storing arrays.
  This parameter is only honored when the store is created, otherwise it is ignored.
  The default block size is 120 bytes, and the overhead of each block is the same as for string blocks, i.e., 8 bytes.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">dump_configuration</code></p></td><td align="left" valign="top"><p><code class="literal">true</code> or <code class="literal">false</code></p></td><td align="left" valign="top"><p>If set to <code class="literal">true</code> the current configuration settings will be written to the default system output, mostly the console or the logfiles.</p></td></tr></tbody></table></div><p>When memory mapped buffers are used (<code class="literal">use_memory_mapped_buffers = true</code>) the heap size of the JVM must be smaller than the total available memory of the computer, minus the total amount of memory used for the buffers.
When heap buffers are used (<code class="literal">use_memory_mapped_buffers = false</code>) the heap size of the JVM must be large enough to contain all the buffers, plus the runtime heap memory requirements of the application and the object cache.</p><p>When reading the configuration parameters on startup Neo4j will automatically configure the parameters that are not specified.
The cache sizes will be configured based on the available memory on the computer, how much is used by the JVM heap, and how large the storage files are.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_object_cache"></a>21.4.2. Object cache</h3></div></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Quick info</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The object cache is sometimes called <span class="emphasis"><em>high level cache</em></span>.
</li><li class="listitem">
It caches the Neo4j data in a form optimized for fast traversal.
</li></ul></div></div><p>The object cache caches individual nodes and relationships and their properties in a form that is optimized for fast traversal of the graph.
There are two different categories of object caches in Neo4j.</p><p>There is the reference caches.
Here Neo4j will utilize as much as it can out of the allocated heap memory for the JVM for object caching and relies on garbage collection for eviction from the cache in an LRU manner.
Note however that Neo4j is "competing" for the heap space with other objects in the same JVM, such as a your application, if deployed in embedded mode, and Neo4j will let the application "win" by using less memory if the application needs more.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/admon/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The GC resistant cache described below is only available in the Neo4j Enterprise Edition.</p></td></tr></table></div><p>The other is the <span class="emphasis"><em>GC resistant cache</em></span> which gets assigned a certain amount of space in the JVM heap and will purge objects whenever it grows bigger than that.
It is assigned a maximum amount of memory which the sum of all cached objects in it will not exceed.
Objects will be evicted from cache when the maximum size is about to be reached, instead of relying on garbage collection (GC) to make that decision.
Here the competition with other objects in the heap as well as GC-pauses can be better controlled since the cache gets assigned a maximum heap space usage.
The overhead of the GC resistant cache is also much smaller as well as insert/lookup times faster than for reference caches.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/admon/tip.png" /></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The use of heap memory is subject to the java garbage collector — depending on the cache type some tuning might be needed to play well with the GC at large heap sizes.
Therefore, assigning a large heap for Neo4j’s sake isn’t always the best strategy as it may lead to long GC-pauses.
Instead leave some space for Neo4j’s filesystem caches.
These are outside of the heap and under under the kernel’s direct control, thus more efficiently managed.</p></td></tr></table></div><p>The content of this cache are objects with a representation geared towards supporting the Neo4j object API and graph traversals.
Reading from this cache is 5 to 10 times faster than reading from the file buffer cache.
This cache is contained in the heap of the JVM and the size is adapted to the current amount of available heap memory.</p><p>Nodes and relationships are added to the object cache as soon as they are accessed.
The cached objects are however populated lazily.
The properties for a node or relationship are not loaded until properties are accessed for that node or relationship.
String (and array) properties are not loaded until that particular property is accessed.
The relationships for a particular node is also not loaded until the relationships are accessed for that node.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_configuration_2"></a>Configuration</h4></div></div></div><p>The main configuration parameter for the object cache is the <code class="literal">cache_type</code> parameter.
This specifies which cache implementation to use for the object cache.
Note that there will exist two cache instances, one for nodes and one for relationships.
The available cache types are:</p><div class="informaltable"><table cellspacing="0" cellpadding="0" border="0"><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th align="left" valign="top"> <code class="literal">cache_type</code> </th><th align="left" valign="top"> Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">none</code></p></td><td align="left" valign="top"><p>Do not use a high level cache. No objects will be cached.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">soft</code></p></td><td align="left" valign="top"><p>Provides optimal utilization of the available memory.
                 Suitable for high performance traversal.
                 May run into GC issues under high load if the frequently accessed parts of the graph does not fit in the cache.</p>
<p>                 This is the default cache implementation.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">weak</code></p></td><td align="left" valign="top"><p>Provides short life span for cached objects.
                 Suitable for high throughput applications where a larger portion of the graph than what can fit into memory is frequently accessed.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">strong</code></p></td><td align="left" valign="top"><p>This cache will hold on to <span class="strong"><strong>all data</strong></span> that gets loaded to never release it again.
                 Provides good performance if your graph is small enough to fit in memory.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">gcr</code></p></td><td align="left" valign="top"><p>Provides means of assigning a specific amount of memory to dedicate to caching loaded nodes and relationships.
                 Small footprint and fast insert/lookup. Should be the best option for most scenarios. See below on how to configure it.
                 Note that this option is only available in the Neo4j Enterprise Edition.</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_gc_resistant_cache_configuration"></a>GC resistant cache configuration</h4></div></div></div><p>Since the GC resistant cache operates with a maximum size in the JVM it may be configured per use case for optimal performance.
There are two aspects of the cache size.</p><p>One is the size of the array referencing the objects that are put in the cache.
It is specified as a fraction of the heap, for example specifying <code class="literal">5</code> will let that array itself take up 5% out of the entire heap.
Increasing this figure (up to a maximum of 10) will reduce the chance of hash collisions at the expense of more heap used for it.
More collisions means more redundant loading of objects from the low level cache.</p><div class="informaltable"><table cellspacing="0" cellpadding="0" border="0"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th align="left" valign="top"> <code class="literal">configuration option</code>            </th><th align="left" valign="top"> Description (what it controls)                                                                 </th><th align="left" valign="top"> Example value</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">node_cache_array_fraction</code></p></td><td align="left" valign="top"><p>Fraction of the heap to dedicate to the array holding the nodes in the cache (max 10).</p></td><td align="left" valign="top"><p><code class="literal">7</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">relationship_cache_array_fraction</code></p></td><td align="left" valign="top"><p>Fraction of the heap to dedicate to the array holding the relationships in the cache (max 10).</p></td><td align="left" valign="top"><p><code class="literal">5</code></p></td></tr></tbody></table></div><p>The other aspect is the maximum size of all the objects in the cache. It is specified as size in bytes, for example <code class="literal">500M</code> for 500 megabytes or <code class="literal">2G</code> for two gigabytes.
Right before the maximum size is reached a <code class="literal">purge</code> is performed where (currently) random objects are evicted from the cache until the cache size gets below 90% of the maximum size.
Optimal settings for the maximum size depends on the size of your graph.
The configured maximum size should leave enough room for other objects to coexist in the same JVM, but at the same time large enough to keep loading from the low level cache at a minimum.
Predicted load on the JVM as well as layout of domain level objects should also be take into consideration.</p><div class="informaltable"><table cellspacing="0" cellpadding="0" border="0"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th align="left" valign="top"> <code class="literal">configuration option</code>   </th><th align="left" valign="top"> Description (what it controls)                                           </th><th align="left" valign="top"> Example value</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">node_cache_size</code></p></td><td align="left" valign="top"><p>Maximum size of the heap memory to dedicate to the cached nodes.</p></td><td align="left" valign="top"><p><code class="literal">2G</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">relationship_cache_size</code></p></td><td align="left" valign="top"><p>Maximum size of the heap memory to dedicate to the cached relationships.</p></td><td align="left" valign="top"><p><code class="literal">800M</code></p></td></tr></tbody></table></div><p>You can read about references and relevant JVM settings for Sun HotSpot here:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<a class="ulink" href="http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html" target="_top">Understanding soft/weak references</a>
</li><li class="listitem">
<a class="ulink" href="http://jeremymanson.blogspot.com/2009/07/how-hotspot-decides-to-clear_07.html" target="_top">How Hotspot Decides to Clear SoftReferences</a>
</li><li class="listitem">
<a class="ulink" href="http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs" target="_top">HotSpot FAQ</a>
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_heap_memory_usage"></a>Heap memory usage</h4></div></div></div><p>This table can be used to calculate how much memory the data in the object cache will occupy on a 64bit JVM:</p><div class="informaltable"><table cellspacing="0" cellpadding="0" border="0"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th align="left" valign="top"> Object           </th><th align="left" valign="top"> Size  </th><th align="left" valign="top"> Comment</th></tr></thead><tbody><tr><td rowspan="5" align="left" valign="top"><p>Node</p></td><td align="right" valign="top"><p><code class="literal">344 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Size for each node (not counting its relationships or properties).</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">48 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Object overhead.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">136 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Property storage (ArrayMap <code class="literal">48B</code>, HashMap <code class="literal">88B</code>).</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">136 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Relationship storage (ArrayMap <code class="literal">48B</code>, HashMap <code class="literal">88B</code>).</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">24 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Location of first / next set of relationships.</em></span></p></td></tr><tr><td rowspan="3" align="left" valign="top"><p>Relationship</p></td><td align="right" valign="top"><p><code class="literal">208 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Size for each relationship (not counting its properties).</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">48 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Object overhead.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">136 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Property storage (ArrayMap <code class="literal">48B</code>, HashMap <code class="literal">88B</code>).</em></span></p></td></tr><tr><td rowspan="5" align="left" valign="top"><p>Property</p></td><td align="right" valign="top"><p><code class="literal">116 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Size for each property of a node or relationship.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">32 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Data element — allows for transactional modification and keeps track of on disk location.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">48 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Entry in the hash table where it is stored.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">12 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Space used in hash table, accounts for normal fill ratio.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">24 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Property key index.</em></span></p></td></tr><tr><td rowspan="4" align="left" valign="top"><p>Relationships</p></td><td align="right" valign="top"><p><code class="literal">108 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Size for each relationship type for a node that has a relationship of that type.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">48 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Collection of the relationships of this type.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">48 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Entry in the hash table where it is stored.</em></span></p></td></tr><tr><td align="right" valign="top"><p><code class="literal">12 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Space used in hash table, accounts for normal fill ratio.</em></span></p></td></tr><tr><td align="left" valign="top"><p>Relationships</p></td><td align="right" valign="top"><p><code class="literal">8 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Space used by each relationship related to a particular node (both incoming and outgoing).</em></span></p></td></tr><tr><td align="left" valign="top"><p>Primitive</p></td><td align="right" valign="top"><p><code class="literal">24 B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Size of a primitive property value.</em></span></p></td></tr><tr><td align="left" valign="top"><p>String</p></td><td align="right" valign="top"><p><code class="literal">64+B</code></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Size of a string property value. <code class="literal">64 + 2*len(string) B</code> (64 bytes, plus two bytes for each character in the string).</em></span></p></td></tr></tbody></table></div></div></div></div><HR xmlns=""></HR><a xmlns="" href="ln-idp3423008.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2013 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="kernel-configuration.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="embedded-configuration.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="configuration-logical-logs.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
