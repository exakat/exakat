<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4.5. Traversal</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The Neo4j Manual v1.9.M04" /><link rel="up" href="tutorials-java-embedded.html" title="Chapter 4. Using Neo4j embedded in Java applications" /><link rel="prev" href="tutorials-java-unit-testing.html" title="4.4. Basic unit testing" /><link rel="next" href="tutorials-java-embedded-entities.html" title="4.6. Domain entities" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 4. Using Neo4j embedded in Java applications" /><link rel="chapter" href="tutorials-rest.html" title="Chapter 5. Neo4j Remote Client Libraries" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 6. The Traversal Framework" /><link rel="chapter" href="data-modeling-examples.html" title="Chapter 7. Data Modeling Examples" /><link rel="chapter" href="languages.html" title="Chapter 8. Languages" /><link rel="chapter" href="tutorials-python-embedded.html" title="Chapter 9. Using Neo4j embedded in Python applications" /><link rel="chapter" href="server-extending.html" title="Chapter 10. Extending the Neo4j Server" /><link rel="part" href="reference-documentation.html" title="Part III. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 11. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 12. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 13. Data Import" /><link rel="chapter" href="indexing.html" title="Chapter 14. Indexing" /><link rel="chapter" href="cypher-query-lang.html" title="Chapter 15. Cypher Query Language" /><link rel="chapter" href="graph-algo.html" title="Chapter 16. Graph Algorithms" /><link rel="chapter" href="server.html" title="Chapter 17. Neo4j Server" /><link rel="chapter" href="rest-api.html" title="Chapter 18. REST API" /><link rel="chapter" href="python-embedded.html" title="Chapter 19. Python embedded bindings" /><link rel="part" href="operations.html" title="Part IV. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 20. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 21. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 22. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 23. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 24. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 25. Monitoring" /><link rel="part" href="tools.html" title="Part V. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 26. Web Administration" /><link rel="chapter" href="shell.html" title="Chapter 27. Neo4j Shell" /><link rel="part" href="community.html" title="Part VI. Community" /><link rel="chapter" href="community-support.html" title="Chapter 28. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 29. Contributing to Neo4j" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-shell" /><link rel="refentry" href="re03.html" title="neo4j-backup" /><link rel="appendix" href="questions.html" title="Appendix B. Questions &amp; Answers" /><link rel="subsection" href="tutorials-java-embedded-traversal.html#_the_matrix" title="4.5.1. The Matrix" /><link rel="subsection" href="tutorials-java-embedded-traversal.html#_old_traversal_api" title="4.5.2. Old traversal API" /><link rel="subsection" href="tutorials-java-embedded-traversal.html#examples-uniqueness-of-paths-in-traversals" title="4.5.3. Uniqueness of Paths in traversals" /><link rel="subsection" href="tutorials-java-embedded-traversal.html#tutorials-java-embedded-social" title="4.5.4. Social network" /><link rel="copyright" href="ln-idp3423008.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>
<script type="text/javascript" src="js/shBrushProperties.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="tutorials.html">Tutorials</a></span> &gt; <span class="breadcrumb-link"><a href="tutorials-java-embedded.html">Using Neo4j embedded in Java applications</a></span> &gt; <span class="breadcrumb-node">Traversal</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="tutorials-java-unit-testing.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="tutorials-java-embedded-entities.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="tutorials-java-embedded-traversal"></a>4.5. Traversal</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="tutorials-java-embedded-traversal.html#_the_matrix">4.5.1. The Matrix</a></span></dt><dt><span class="section"><a href="tutorials-java-embedded-traversal.html#_old_traversal_api">4.5.2. Old traversal API</a></span></dt><dt><span class="section"><a href="tutorials-java-embedded-traversal.html#examples-uniqueness-of-paths-in-traversals">4.5.3. Uniqueness of Paths in traversals</a></span></dt><dt><span class="section"><a href="tutorials-java-embedded-traversal.html#tutorials-java-embedded-social">4.5.4. Social network</a></span></dt></dl></div><p>For reading about traversals, see <a class="xref" href="tutorial-traversal.html" title="Chapter 6. The Traversal Framework">Chapter 6, <em>The Traversal Framework</em></a>.</p><p>For more examples of traversals, see <a class="xref" href="data-modeling-examples.html" title="Chapter 7. Data Modeling Examples">Chapter 7, <em>Data Modeling Examples</em></a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_the_matrix"></a>4.5.1. The Matrix</h3></div></div></div><p>The traversals from the Matrix example above, this time using the new traversal API:</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/admon/tip.png" /></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The source code of the examples is found here:
<a class="ulink" href="https://github.com/neo4j/neo4j/blob/1.9.M04/community/embedded-examples/src/main/java/org/neo4j/examples/NewMatrix.java" target="_top">NewMatrix.java</a></p></td></tr></table></div><p><strong>Friends and friends of friends. </strong>
</p><pre class="programlisting brush: java">private static Traverser getFriends(
        final Node person )
{
    TraversalDescription td = Traversal.description()
            .breadthFirst()
            .relationships( RelTypes.KNOWS, Direction.OUTGOING )
            .evaluator( Evaluators.excludeStartPosition() );
    return td.traverse( person );
}
</pre><p>
</p><p>Let’s perform the actual traversal and print the results:</p><pre class="programlisting brush: java">int numberOfFriends = 0;
String output = neoNode.getProperty( "name" ) + "'s friends:\n";
Traverser friendsTraverser = getFriends( neoNode );
for ( Path friendPath : friendsTraverser )
{
    output += "At depth " + friendPath.length() + " =&gt; "
              + friendPath.endNode()
                      .getProperty( "name" ) + "\n";
    numberOfFriends++;
}
output += "Number of friends found: " + numberOfFriends + "\n";
</pre><p>Which will give us the following output:</p><pre class="programlisting brush: plain">Thomas Anderson's friends:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
Number of friends found: 4</pre><p><strong>Who coded the Matrix? </strong>
</p><pre class="programlisting brush: java">private static Traverser findHackers( final Node startNode )
{
    TraversalDescription td = Traversal.description()
            .breadthFirst()
            .relationships( RelTypes.CODED_BY, Direction.OUTGOING )
            .relationships( RelTypes.KNOWS, Direction.OUTGOING )
            .evaluator(
                    Evaluators.includeWhereLastRelationshipTypeIs( RelTypes.CODED_BY ) );
    return td.traverse( startNode );
}
</pre><p>
</p><p>Print out the result:</p><pre class="programlisting brush: java">String output = "Hackers:\n";
int numberOfHackers = 0;
Traverser traverser = findHackers( getNeoNode() );
for ( Path hackerPath : traverser )
{
    output += "At depth " + hackerPath.length() + " =&gt; "
              + hackerPath.endNode()
                      .getProperty( "name" ) + "\n";
    numberOfHackers++;
}
output += "Number of hackers found: " + numberOfHackers + "\n";
</pre><p>Now we know who coded the Matrix:</p><pre class="programlisting brush: plain">Hackers:
At depth 4 =&gt; The Architect
Number of hackers found: 1</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_walking_an_ordered_path"></a>Walking an ordered path</h4></div></div></div><p>This example shows how to use a path context holding a representation of a path.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/admon/tip.png" /></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The source code of this example is found here:
<a class="ulink" href="https://github.com/neo4j/neo4j/blob/1.9.M04/community/embedded-examples/src/main/java/org/neo4j/examples/orderedpath/OrderedPath.java" target="_top">OrderedPath.java</a></p></td></tr></table></div><p><strong>Create a toy graph. </strong>
</p><pre class="programlisting brush: java">Node A = db.createNode();
Node B = db.createNode();
Node C = db.createNode();
Node D = db.createNode();
A.createRelationshipTo( B, REL1 );
B.createRelationshipTo( C, REL2 );
C.createRelationshipTo( D, REL3 );
A.createRelationshipTo( C, REL2 );
</pre><p>
</p><div class="informalfigure"><a class="ulink" href="images/example-ordered-path.svg" target="_top">
<span class="inlinemediaobject"><img src="images/example-ordered-path.svg" alt="example-ordered-path.svg" /></span>
</a></div><p>Now, the order of relationships (<code class="literal">REL1</code> → <code class="literal">REL2</code> → <code class="literal">REL3</code>) is stored in an <code class="literal">ArrayList</code>.
Upon traversal, the <code class="literal">Evaluator</code> can check against it to ensure that only paths are included and returned that have the predefined order of relationships:</p><p><strong>Define how to walk the path. </strong>
</p><pre class="programlisting brush: java">final ArrayList&lt;RelationshipType&gt; orderedPathContext = new ArrayList&lt;RelationshipType&gt;();
orderedPathContext.add( REL1 );
orderedPathContext.add( withName( "REL2" ) );
orderedPathContext.add( withName( "REL3" ) );
TraversalDescription td = Traversal.description()
        .evaluator( new Evaluator()
        {
            @Override
            public Evaluation evaluate( final Path path )
            {
                if ( path.length() == 0 )
                {
                    return Evaluation.EXCLUDE_AND_CONTINUE;
                }
                RelationshipType expectedType = orderedPathContext.get( path.length() - 1 );
                boolean isExpectedType = path.lastRelationship()
                        .isType( expectedType );
                boolean included = path.length() == orderedPathContext.size()
                                   &amp;&amp; isExpectedType;
                boolean continued = path.length() &lt; orderedPathContext.size()
                                    &amp;&amp; isExpectedType;
                return Evaluation.of( included, continued );
            }
        } );
</pre><p>
</p><p><strong>Perform the traversal and print the result. </strong>
</p><pre class="programlisting brush: java">Traverser traverser = td.traverse( A );
PathPrinter pathPrinter = new PathPrinter( "name" );
for ( Path path : traverser )
{
    output += Traversal.pathToString( path, pathPrinter );
}
</pre><p>
</p><p>Which will output:</p><pre class="programlisting brush: plain">(A)--[REL1]--&gt;(B)--[REL2]--&gt;(C)--[REL3]--&gt;(D)</pre><p>In this case we use a custom class to format the path output.
This is how it’s done:</p><pre class="programlisting brush: java">static class PathPrinter implements Traversal.PathDescriptor&lt;Path&gt;
{
    private final String nodePropertyKey;

    public PathPrinter( String nodePropertyKey )
    {
        this.nodePropertyKey = nodePropertyKey;
    }

    @Override
    public String nodeRepresentation( Path path, Node node )
    {
        return "(" + node.getProperty( nodePropertyKey, "" ) + ")";
    }

    @Override
    public String relationshipRepresentation( Path path, Node from,
            Relationship relationship )
    {
        String prefix = "--", suffix = "--";
        if ( from.equals( relationship.getEndNode() ) )
        {
            prefix = "&lt;--";
        }
        else
        {
            suffix = "--&gt;";
        }
        return prefix + "[" + relationship.getType().name() + "]" + suffix;
    }
}
</pre><p>For options regarding output of a <code class="literal">Path</code>, see the
<a class="ulink" href="http://components.neo4j.org/neo4j/1.9.M04/apidocs/org/neo4j/kernel/Traversal.html" target="_top">Traversal</a> class.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/admon/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The following examples use a deprecated traversal API.
It shares the underlying implementation with the new traversal API, so performance-wise they are equal.
The functionality it provides is very limited in comparison.</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_old_traversal_api"></a>4.5.2. Old traversal API</h3></div></div></div><p>This is the first graph we want to traverse into:</p><div class="figure"><a id="idp6083424"></a><p class="title"><strong>Figure 4.3. Matrix node space view</strong></p><div class="figure-contents"><a class="ulink" href="images/examples-matrix.png" target="_top">
<span class="inlinemediaobject"><img src="images/examples-matrix.png" width="75%" alt="examples-matrix.png" /></span>
</a></div></div><br class="figure-break" /><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/admon/tip.png" /></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The source code of the examples is found here:
<a class="ulink" href="https://github.com/neo4j/neo4j/blob/1.9.M04/community/embedded-examples/src/main/java/org/neo4j/examples/Matrix.java" target="_top">Matrix.java</a></p></td></tr></table></div><p><strong>Friends and friends of friends. </strong>
</p><pre class="programlisting brush: java">private static Traverser getFriends( final Node person )
{
    return person.traverse( Order.BREADTH_FIRST,
            StopEvaluator.END_OF_GRAPH,
            ReturnableEvaluator.ALL_BUT_START_NODE, RelTypes.KNOWS,
            Direction.OUTGOING );
}
</pre><p>
</p><p>Let’s perform the actual traversal and print the results:</p><pre class="programlisting brush: java">int numberOfFriends = 0;
String output = neoNode.getProperty( "name" ) + "'s friends:\n";
Traverser friendsTraverser = getFriends( neoNode );
for ( Node friendNode : friendsTraverser )
{
    output += "At depth " +
                friendsTraverser.currentPosition().depth() +
                " =&gt; " +
                friendNode.getProperty( "name" ) + "\n";
    numberOfFriends++;
}
output += "Number of friends found: " + numberOfFriends + "\n";
</pre><p>Which will give us the following output:</p><pre class="programlisting brush: plain">Thomas Anderson's friends:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
Number of friends found: 4</pre><p><strong>Who coded the Matrix? </strong>
</p><pre class="programlisting brush: java">private static Traverser findHackers( final Node startNode )
{
    return startNode.traverse( Order.BREADTH_FIRST,
            StopEvaluator.END_OF_GRAPH, new ReturnableEvaluator()
    {
        @Override
        public boolean isReturnableNode(
                final TraversalPosition currentPos )
        {
            return !currentPos.isStartNode()
            &amp;&amp; currentPos.lastRelationshipTraversed()
            .isType( RelTypes.CODED_BY );
        }
    }, RelTypes.CODED_BY, Direction.OUTGOING, RelTypes.KNOWS,
    Direction.OUTGOING );
}
</pre><p>
</p><p>Print out the result:</p><pre class="programlisting brush: java">String output = "Hackers:\n";
int numberOfHackers = 0;
Traverser traverser = findHackers( getNeoNode() );
for ( Node hackerNode : traverser )
{
    output += "At depth " +
                traverser.currentPosition().depth() +
                " =&gt; " +
                hackerNode.getProperty( "name" ) + "\n";
    numberOfHackers++;
}
output += "Number of hackers found: " + numberOfHackers + "\n";
</pre><p>Now we know who coded the Matrix:</p><pre class="programlisting brush: plain">Hackers:
At depth 4 =&gt; The Architect
Number of hackers found: 1</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="examples-uniqueness-of-paths-in-traversals"></a>4.5.3. Uniqueness of Paths in traversals</h3></div></div></div><p>This example is demonstrating the use of node uniqueness.
Below an imaginary domain graph with Principals
that own pets that are descendant to other pets.</p><div class="figure"><a id="idp6102176"></a><p class="title"><strong>Figure 4.4. Descendants Example Graph</strong></p><div class="figure-contents"><a class="ulink" href="images/Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg" target="_top">
<span class="inlinemediaobject"><img src="images/Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg" alt="Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg" /></span>
</a></div></div><br class="figure-break" /><p>In order to return all descendants
of <code class="literal">Pet0</code> which have the relation <code class="literal">owns</code> to <code class="literal">Principal1</code> (<code class="literal">Pet1</code> and <code class="literal">Pet3</code>),
the Uniqueness of the traversal needs to be set to
<code class="literal">NODE_PATH</code> rather than the default <code class="literal">NODE_GLOBAL</code> so that nodes
can be traversed more that once, and paths that have
different nodes but can have some nodes in common (like the
start and end node) can be returned.</p><pre class="programlisting brush: java">final Node target = data.get().get( "Principal1" );
TraversalDescription td = Traversal.description()
        .uniqueness( Uniqueness.NODE_PATH )
        .evaluator( new Evaluator()
{
    @Override
    public Evaluation evaluate( Path path )
    {
        if ( path.endNode().equals( target ) )
        {
            return Evaluation.INCLUDE_AND_PRUNE;
        }
        return Evaluation.EXCLUDE_AND_CONTINUE;
    }
} );

Traverser results = td.traverse( start );
</pre><p>This will return the following paths:</p><pre class="programlisting brush: plain">(3)--[descendant,0]--&gt;(1)&lt;--[owns,3]--(5)
(3)--[descendant,2]--&gt;(4)&lt;--[owns,5]--(5)</pre><p>In the default <code class="literal">path.toString()</code> implementation, <code class="literal">(1)--[knows,2]--&gt;(4)</code> denotes
a node with ID=1 having a relationship with ID 2 or type <code class="literal">knows</code> to a node with ID-4.</p><p>Let’s create a new <code class="literal">TraversalDescription</code> from the old one,
having <code class="literal">NODE_GLOBAL</code> uniqueness to see the difference.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/admon/tip.png" /></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The <code class="literal">TraversalDescription</code> object is immutable,
     so we have to use the new instance returned
     with the new uniqueness setting.</p></td></tr></table></div><pre class="programlisting brush: java">TraversalDescription nodeGlobalTd = td.uniqueness( Uniqueness.NODE_GLOBAL );
results = nodeGlobalTd.traverse( start );
</pre><p>Now only one path is returned:</p><pre class="programlisting brush: plain">(3)--[descendant,0]--&gt;(1)&lt;--[owns,3]--(5)</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="tutorials-java-embedded-social"></a>4.5.4. Social network</h3></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/admon/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The following example uses the new enhanced traversal API.</p></td></tr></table></div><p>Social networks (know as social graphs out on the web) are natural to model with a graph.
This example shows a very simple social model that connects friends and keeps track of status updates.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/admon/tip.png" /></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The source code of the example is found here:
<a class="ulink" href="https://github.com/neo4j/neo4j/tree/1.9.M04/community/embedded-examples/src/main/java/org/neo4j/examples/socnet" target="_top">socnet</a></p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_simple_social_model"></a>Simple social model</h4></div></div></div><div class="figure"><a id="idp6126800"></a><p class="title"><strong>Figure 4.5. Social network data model</strong></p><div class="figure-contents"><a class="ulink" href="images/socnet-model.png" target="_top">
<span class="inlinemediaobject"><img src="images/socnet-model.png" width="60%" alt="socnet-model.png" /></span>
</a></div></div><br class="figure-break" /><p>The data model for a social network is pretty simple: <code class="literal">Persons</code> with names and <code class="literal">StatusUpdates</code> with timestamped text.
These entities are then connected by specific relationships.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">Person</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">friend</code>: relates two distinct <code class="literal">Person</code> instances (no self-reference)
</li><li class="listitem">
<code class="literal">status</code>: connects to the most recent <code class="literal">StatusUpdate</code>
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">StatusUpdate</code>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<code class="literal">next</code>: points to the next <code class="literal">StatusUpdate</code> in the chain, which was posted before the current one
</li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_status_graph_instance"></a>Status graph instance</h4></div></div></div><p>The <code class="literal">StatusUpdate</code> list for a <code class="literal">Person</code> is a linked list.
The head of the list (the most recent status) is found by following <code class="literal">status</code>.
Each subsequent <code class="literal">StatusUpdate</code> is connected by <code class="literal">next</code>.</p><p>Here’s an example where Andreas Kollegger micro-blogged his way to work in the morning:</p><div class="informalfigure"><a class="ulink" href="images/andreas-status-updates.svg" target="_top">
<span class="inlinemediaobject"><img src="images/andreas-status-updates.svg" alt="andreas-status-updates.svg" /></span>
</a></div><p>To read the status updates, we can create a traversal, like so:</p><pre class="programlisting brush: java">TraversalDescription traversal = Traversal.description().
        depthFirst().
        relationships( NEXT );
</pre><p>This gives us a traverser that will start at one <code class="literal">StatusUpdate</code>, and will follow the chain of updates until they run out.
Traversers are lazy loading, so it’s performant even when dealing with thousands of statuses — they are not loaded until we actually consume them.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_activity_stream"></a>Activity stream</h4></div></div></div><p>Once we have friends, and they have status messages, we might want to read our friends status' messages, in reverse time order — latest first.
To do this, we go through these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Gather all friend’s status update iterators in a list — latest date first.
</li><li class="listitem">
Sort the list.
</li><li class="listitem">
Return the first item in the list.
</li><li class="listitem">
If the first iterator is exhausted, remove it from the list.
  Otherwise, get the next item in that iterator.
</li><li class="listitem">
Go to step 2 until there are no iterators left in the list.
</li></ol></div><p>Animated, the sequence looks like <a class="ulink" href="http://www.slideshare.net/systay/pattern-activity-stream" target="_top">this</a>.</p><p>The code looks like:</p><pre class="programlisting brush: java">PositionedIterator&lt;StatusUpdate&gt; first = statuses.get(0);
StatusUpdate returnVal = first.current();

if ( !first.hasNext() )
{
    statuses.remove( 0 );
}
else
{
    first.next();
    sort();
}

return returnVal;
</pre></div></div></div><HR xmlns=""></HR><a xmlns="" href="ln-idp3423008.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2013 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorials-java-unit-testing.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="tutorials-java-embedded.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="tutorials-java-embedded-entities.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
